package static

import (
	"context"
	"embed"
	"fmt"
	"io/fs"
	"path"
	"strings"

	serrors "github.com/slsa-framework/slsa-verifier/v2/errors"
	"github.com/slsa-framework/slsa-verifier/v2/options"
	register "github.com/slsa-framework/slsa-verifier/v2/register"
	"github.com/slsa-framework/slsa-verifier/v2/verifiers/internal/vsas"
	"github.com/slsa-framework/slsa-verifier/v2/verifiers/utils"
)

const VerifierName = "StaticKey"

//nolint:gochecknoinits
func init() {
	register.RegisterVsaVerifier(VerifierName, StaticKeyVerifierNew())
}

type metadata struct {
	id       string // name without the version part.
	keyfile  string
	keyid    string
	encoding utils.SignatureEncoding
}

var metadatas = []metadata{
	{
		id:       "https://bcid.corp.google.com/verifier/bcid_package_enforcer",
		encoding: utils.SignatureEncodingIEEE_P1363,
		keyid:    "keystore://76574:prod:vsa_signing_public_key",
		keyfile:  "google.key",
	},
}

//go:embed materials/*
var publicKeys embed.FS

// This defines a static key.
type StaticKeyVerifier struct {
	metadata *metadata
}

func StaticKeyVerifierNew() *StaticKeyVerifier {
	return &StaticKeyVerifier{}
}

// IsAuthoritativeFor returns true of the verifier can verify provenance
// generated by the builderID.
func (v *StaticKeyVerifier) IsAuthoritativeFor(verifierID string) bool {
	for i := range metadatas {
		if strings.HasPrefix(verifierID, metadatas[i].id) {
			v.metadata = &metadatas[i]
			return true
		}
	}
	return false
}

// VerifyArtifact verifies VSA for an artifact.
func (v *StaticKeyVerifier) VerifyArtifact(ctx context.Context,
	vsa []byte,
	vsaOpts *options.VsaOpts,
	verifierOpts *options.VerifierOpts,
) ([]byte, *utils.TrustedVerifierID, error) {
	if v.metadata == nil {
		return nil, nil, fmt.Errorf("%w: empty metadata", serrors.ErrorInternal)
	}
	// Read the static key.
	key, err := fs.ReadFile(publicKeys, path.Join("materials", v.metadata.keyfile))
	if err != nil {
		return nil, nil, fmt.Errorf("%w: cannot read key materials", err)
	}

	// Create a DSSE verifier.
	dsseVerifier, err := utils.DsseVerifierNew(key, v.metadata.keyid)
	if err != nil {
		return nil, nil, err
	}

	// Create a VSA verifier.
	vsaVerifier, err := vsas.VsaVerifierNew(vsa, dsseVerifier)
	if err != nil {
		return nil, nil, err
	}

	// Verify the VSA.
	verifierID, err := vsaVerifier.Verify(ctx, vsaOpts, verifierOpts, v.metadata.encoding)
	if err != nil {
		return nil, nil, err
	}

	return vsa, verifierID, nil
}

// VerifyNpmPackage verifies an npm package tarball.
func (v *StaticKeyVerifier) VerifyNpmPackage(ctx context.Context,
	attestations []byte,
	vsaOpts *options.VsaOpts,
	verifierOpts *options.VerifierOpts,
) ([]byte, *utils.TrustedVerifierID, error) {
	return nil, nil, serrors.ErrorNotSupported
}

// VerifyImage verifies VSA for an OCI image.
func (v *StaticKeyVerifier) VerifyImage(ctx context.Context,
	artifactImage string, vsa []byte,
	vsaOpts *options.VsaOpts,
	verifierOpts *options.VerifierOpts,
) ([]byte, *utils.TrustedVerifierID, error) {
	return nil, nil, serrors.ErrorNotSupported
}
