package v1

import (
	"fmt"

	serrors "github.com/slsa-framework/slsa-verifier/v2/errors"
	"github.com/slsa-framework/slsa-verifier/v2/verifiers/internal/gha/slsaprovenance/iface"
)

// CLIBasedBuildType is the build type for the default GitHub workflow, e.g. for npm CLI.
var CLIBasedBuildType = "https://slsa-framework.github.io/github-actions-buildtypes/workflow/v1"

// CLIBasedProvenance is provenance generated by the GitHub workflow via a CLI.
type CLIBasedProvenance struct {
	*provenanceV1
}

func newCLIBuilderProvenance(a *Attestation) iface.Provenance {
	return &CLIBasedProvenance{
		provenanceV1: &provenanceV1{
			prov: a,
		},
	}
}

// TriggerURI implements Provenance.TriggerURI.
func (p *CLIBasedProvenance) TriggerURI() (string, error) {
	sysParams, ok := p.prov.Predicate.BuildDefinition.ExternalParameters.(map[string]interface{})
	if !ok {
		return "", fmt.Errorf("%w: %s", serrors.ErrorInvalidDssePayload, "system parameters type")
	}

	w, ok := sysParams["workflow"]
	if !ok {
		return "", fmt.Errorf("%w: %s", serrors.ErrorInvalidDssePayload, "workflow parameters type")
	}

	wMap, ok := w.(map[string]interface{})
	if !ok {
		return "", fmt.Errorf("%w: %s", serrors.ErrorInvalidDssePayload, "workflow not a map")
	}

	ref, ok := wMap["ref"]
	if !ok {
		return "", fmt.Errorf("%w: %s", serrors.ErrorInvalidDssePayload, "no ref entry on workflow")
	}

	repo, ok := wMap["repository"]
	if !ok {
		return "", fmt.Errorf("%w: %s", serrors.ErrorInvalidDssePayload, "no repository entry on workflow")
	}

	if repo == "" || ref == "" {
		return "", fmt.Errorf("%w: repository or ref is empty", serrors.ErrorMalformedURI)
	}
	return fmt.Sprintf("%s@%s", repo, ref), nil
}
